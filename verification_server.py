# verification_server.py

import json
import sys
import os  # Added for path handling
from flask import Flask, request, jsonify, render_template_string
import firebase_admin
from firebase_admin import credentials, firestore

# Import functions from other modules
import key_manager
# Import only the necessary functions from certificate_utils
from certificate_utils import verify_certificate_data, _extract_device_model

app = Flask(__name__)

# --- Firebase Configuration ---
# Handle bundled paths
if getattr(sys, 'frozen', False):
    base_path = sys._MEIPASS
else:
    base_path = os.path.dirname(os.path.abspath(__file__))

cred_path = os.path.join(base_path, 'firebase-adminsdk.json')
cred = credentials.Certificate(cred_path)
firebase_admin.initialize_app(cred)
db = firestore.client()

# --- Load Public Key On Startup ---
# This ensures the server uses the correct key generated by the app
try:
    TRUSTED_PUBLIC_KEY = key_manager.load_public_key()
    print("Trusted public key loaded successfully.")
except FileNotFoundError:
    print(f"FATAL ERROR: Public key file not found at '{key_manager.PUBLIC_KEY_FILE}'.", file=sys.stderr)
    print("Please run the main application (certiwipe_app.py) once to generate the keys before starting the server.", file=sys.stderr)
    sys.exit(1)
except Exception as e:
    print(f"FATAL ERROR: Could not load public key from file: {e}", file=sys.stderr)
    sys.exit(1)

# --- API Endpoint to Register a Wipe Certificate ---
@app.route('/api/register_wipe', methods=['POST'])
def register_wipe_api():
    cert_data = request.json
    if not cert_data:
        return jsonify({"status": "error", "message": "Invalid request data."}), 400

    # Verify the incoming certificate using the loaded public key
    is_valid, message = verify_certificate_data(cert_data, TRUSTED_PUBLIC_KEY)
    if not is_valid:
        print(f"Certificate registration failed verification: {message}")  # Log failure reason
        return jsonify({"status": "error", "message": f"Certificate verification failed: {message}"}), 400

    try:
        cert_id = cert_data.get('certificateId')
        device_info = cert_data.get('deviceInfo')
        timestamp = cert_data.get('timestampUTC')
        if not all([cert_id, device_info, timestamp]):
            return jsonify({"status": "error", "message": "Missing required certificate data."}), 400

        doc_ref = db.collection('wipes').document(cert_id)
        if doc_ref.get().exists:
            print(f"Attempted to register duplicate certificate ID: {cert_id}")  # Log duplicate attempt
            return jsonify({"status": "error", "message": "Certificate ID already registered."}), 409

        doc_ref.set({
            'certificate_id': cert_id,
            'device_info': json.dumps(device_info),
            'timestamp': timestamp
        })
        print(f"Certificate {cert_id} registered successfully.")  # Log success
        return jsonify({"status": "success", "message": "Certificate registered."}), 201

    except Exception as e:
        print(f"Unexpected error during registration: {e}", file=sys.stderr)  # Log unexpected errors
        return jsonify({"status": "error", "message": f"An unexpected error occurred: {e}"}), 500

# --- Web Page to Verify a Certificate by ID ---
@app.route('/verify/<certificate_id>')
def verify_certificate_web(certificate_id):
    try:
        doc_ref = db.collection('wipes').document(certificate_id)
        doc = doc_ref.get()
        if doc.exists:
            record = doc.to_dict()
            device_info_json = record['device_info']
            timestamp = record['timestamp']
            try:
                device_info = json.loads(device_info_json)
                # Use the _extract_device_model helper for cleaner display
                device_model_name = _extract_device_model(device_info.get('deviceString', 'N/A'))
            except json.JSONDecodeError:
                device_info = {}  # Handle potential bad data
                device_model_name = "Error reading device info"

            html = f"""
            <html><body style='font-family: sans-serif; text-align: center; padding: 20px; background-color: #f9f9f9;'>
                <div style='background-color: white; border: 1px solid #ddd; padding: 20px 40px; display: inline-block; border-radius: 8px;'>
                    <h1 style='color: #27ae60;'>✅ Certificate Verified</h1>
                    <p style='color: #555;'>This certificate ID exists in the official database.</p>
                    <h2 style='color: #333; border-top: 1px solid #eee; padding-top: 15px;'>ID: {certificate_id}</h2>
                    <div style='border: 1px solid #ccc; padding: 15px; border-radius: 5px; background-color: #F0FFFF; text-align: left;'>
                        <p><strong>Device:</strong> {device_model_name}</p>
                        <p><strong>Method:</strong> {device_info.get('wipeMethod', 'N/A')}</p>
                        <p><strong>Timestamp (UTC):</strong> {timestamp}</p>
                    </div>
                    <div style='margin-top: 25px; padding: 10px; background-color: #eaf2f8; border-radius: 5px;'>
                        <p>For offline cryptographic verification, use the 'Verify Certificate' tab in the CertiWipe Pro application.</p>
                    </div>
                </div>
            </body></html>
            """
            return render_template_string(html)
        else:
            return "<h1>❌ Certificate Invalid or Not Found</h1>", 404

    except Exception as e:
        print(f"Unexpected error during verification lookup: {e}", file=sys.stderr)
        return f"<h1>Error: An unexpected error occurred</h1><p>{e}</p>", 500

if __name__ == '__main__':
    # Run the Flask web server
    print("Starting Flask server...")
    app.run(host='0.0.0.0', port=5000)  # Listen on all network interfaces